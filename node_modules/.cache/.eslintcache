[{"/home/chizycodes/Codes/Web3/BCHA/nft-minter-project/src/index.jsx":"1","/home/chizycodes/Codes/Web3/BCHA/nft-minter-project/src/App.jsx":"2","/home/chizycodes/Codes/Web3/BCHA/nft-minter-project/src/components/ERC721Minter.jsx":"3","/home/chizycodes/Codes/Web3/BCHA/nft-minter-project/src/components/ERC721Checker.jsx":"4"},{"size":222,"mtime":1648843710000,"results":"5","hashOfConfig":"6"},{"size":981,"mtime":1648843710000,"results":"7","hashOfConfig":"6"},{"size":3129,"mtime":1658742947913,"results":"8","hashOfConfig":"6"},{"size":1492,"mtime":1648843710000,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"je9zqe",{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"14","messages":"15","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"16"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"19"},"/home/chizycodes/Codes/Web3/BCHA/nft-minter-project/src/index.jsx",[],"/home/chizycodes/Codes/Web3/BCHA/nft-minter-project/src/App.jsx",[],"/home/chizycodes/Codes/Web3/BCHA/nft-minter-project/src/components/ERC721Minter.jsx",["20","21"],"import { useState } from \"react\";\nimport { NFTStorage, File } from \"nft.storage\";\nimport {Camera, FACING_MODES} from 'react-html5-camera-photo';\nimport 'react-html5-camera-photo/build/css/index.css';\n\nconst nftStorage = new NFTStorage({\n  token: process.env.REACT_APP_NFT_STORAGE_KEY,\n});\n\nconst store = async (name, description, data, fileName, type) => {\n  const metadata = await nftStorage.store({\n    name,\n    description,\n    image: new File([data], fileName, { type }),\n  });\n  console.log(metadata);\n  return metadata;\n};\n\nexport const ERC721Minter = ({ bunzz, userAddress }) => {\n  const [blob, setBlob] = useState(null);\n  const [fileName, setFileName] = useState(null);\n  const [base64, setBase64] = useState(null);\n  const [onGoing, setOnGoing] = useState(false);\n  const [tokenId, setTokenId] = useState(null);\n  const [type, setType] = useState(null);\n  const [name, setName] = useState(\"\");\n  const [description, setDescription] = useState(\"\");\n\n  const select = (e) => {\n    const file = e.target.files[0];\n    console.log(file);\n\n    if (file) {\n      readAsBlob(file);\n      readAsBase64(file);\n      setType(file.type);\n      setFileName(file.name);\n    }\n  };\n\n  const readAsBlob = (file) => {\n    const reader = new FileReader();\n    reader.readAsArrayBuffer(file);\n    reader.onload = () => {\n      console.log(reader.result);\n      setBlob(reader.result);\n    };\n  };\n\n  const readAsBase64 = (file) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = () => {\n      console.log(reader.result);\n      setBase64(reader.result);\n    };\n  };\n\n  const submit = async () => {\n    setOnGoing(true);\n    try {\n      const metadata = await store(name, description, blob, fileName, type);\n      const contract = await bunzz.getContract(\"NFT (IPFS Mintable)\");\n      const inputUrl = metadata.url.replace(/^ipfs:\\/\\//, \"\");\n\n      const tx = await contract.safeMint(userAddress, inputUrl);\n      const receipt = await tx.wait();\n      console.log(receipt);\n\n      const event = receipt.events[0];\n      const _tokenId = event.args[2];\n      setTokenId(_tokenId);\n      setBase64(null);\n      window.alert(\"Succeeded to mint\");\n    } catch (err) {\n      console.error(err);\n    } finally {\n      setOnGoing(false);\n    }\n  };\n\n  return (\n    <div className=\"wrapper\">\n      <p className=\"title\">\n        Step1: Mint your NFT with IPFS\n      </p>\n      <input\n        placeholder=\"Token Name\"\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n        type=\"text\"\n      />\n      <input\n        placeholder=\"Description\"\n        value={description}\n        onChange={(e) => setDescription(e.target.value)}\n        type=\"text\"\n      />\n      <input type=\"file\" accept=\"image/*\" onChange={select} />\n      {base64 ? (\n          <img src={base64} alt=\"hoge\" className=\"image\" />\n      ) : (\n        <></>\n      )}\n      {onGoing ? (\n        <div className=\"center\">\n          Loading...\n        </div>\n      ) : (\n        <button onClick={submit}>\n          mint\n        </button>\n      )}\n      {tokenId ? <p>token ID: {tokenId}</p> : <></>}\n    </div>\n  );\n};\n","/home/chizycodes/Codes/Web3/BCHA/nft-minter-project/src/components/ERC721Checker.jsx",["22"],"import { useState } from \"react\";\n\nexport const ERC721Checker = ({ bunzz, userAddress }) => {\n  const [tokenId, setTokenId] = useState(\"\");\n  const [name, setName] = useState(\"\");\n  const [description, setDescription] = useState(\"\");\n  const [image, setImage] = useState(\"\");\n  const [onGoing, setOnGoing] = useState(false);\n\n  const submit = async () => {\n    setOnGoing(true);\n    try {\n      const contract = await bunzz.getContract(\"NFT (IPFS Mintable)\");\n      const { data: tokenUri } = await contract.tokenURI(tokenId);\n      const url = tokenUri.replace(/^ipfs:\\/\\//, \"https://ipfs.io/ipfs/\");\n      const res = await fetch(url);\n      const data = await res.json();\n      setName(data.name);\n      setDescription(data.description);\n      setImage(data.image.replace(/^ipfs:\\/\\//, \"https://ipfs.io/ipfs/\"));\n    } catch (err) {\n      console.error(err);\n    } finally {\n      setOnGoing(false);\n    }\n  };\n\n  return (\n    <div className=\"wrapper\">\n      <p className=\"title\">Step2: Get your NFT</p>\n      <input\n        placeholder=\"token ID\"\n        value={tokenId}\n        onChange={(e) => setTokenId(e.target.value)}\n        type=\"text\"\n      />\n      {onGoing ? (\n        <div className=\"center\">Loading...</div>\n      ) : (\n        <button onClick={submit}>get</button>\n      )}\n      {name ? <p>Name: {name}</p> : <></>}\n      {description ? <p>Description: {description}</p> : <></>}\n      {image ? <img src={image} alt=\"image\" className=\"image\" /> : <></>}\n    </div>\n  );\n};\n",{"ruleId":"23","severity":1,"message":"24","line":3,"column":9,"nodeType":"25","messageId":"26","endLine":3,"endColumn":15},{"ruleId":"23","severity":1,"message":"27","line":3,"column":17,"nodeType":"25","messageId":"26","endLine":3,"endColumn":29},{"ruleId":"28","severity":1,"message":"29","line":44,"column":16,"nodeType":"30","endLine":44,"endColumn":65},"no-unused-vars","'Camera' is defined but never used.","Identifier","unusedVar","'FACING_MODES' is defined but never used.","jsx-a11y/img-redundant-alt","Redundant alt attribute. Screen-readers already announce `img` tags as an image. You donâ€™t need to use the words `image`, `photo,` or `picture` (or any specified custom words) in the alt prop.","JSXOpeningElement"]